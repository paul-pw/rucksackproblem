\documentclass[12pt, a4paper, ngerman]{article}
\title{Das Rucksackproblem}
\author{Paul Walker und Tom Hofer}
\date{30.06.2022}
\newcommand{\Autor}{Paul Walker und Tom Hofer}
\newcommand{\Kurs}{TINF20IN}
\newcommand{\MatrikelNummer}{3610783, 4775319}
\newcommand{\Was}{Hausarbeit Rucksackproblem}
\newcommand{\Studiengang}{Diskrete Mathematik}

\usepackage{biblatex} % für bibliografie
\usepackage{hyperref} % für links zum klicken
\usepackage{color}    % für Farben (benötigt für listings)
\usepackage{listings} % code schnipsel
\usepackage[ngerman]{babel} % lokalisierung der Titel (Inhaltsverzeichniss)
\usepackage{bookmark} % bookmarks für das PDF
\usepackage{csquotes} % korrekte quotes
\usepackage[version=3]{acro} % akronyme
\usepackage{geometry} % seitengeometrie (margin etc einstellen)
\usepackage{parskip}  % zeilenabstand bei neuem paragraph statt indentierung
\usepackage{fancyhdr} % header und footer
\usepackage{array}    % für bessere Tabellen
\usepackage{titlesec} % um die Titel anzupassen
\usepackage{amsfonts} % für \mathbb
\usepackage{placeins} % für \FloatBarrier

\hypersetup{
  pdfauthor={\Autor},
  pdftitle={\Was},
  hidelinks
}

\geometry{
  a4paper,
  left=25mm,
  right=25mm,
  headheight=125mm,
  top=35mm,
  bottom=30mm,
  footskip=15mm
}

% title setup 
% make paragraph have a newline
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% add bibliography
\addbibresource{bibliography.bib}

% header and footer setup
\pagestyle{fancy}
\fancyhf{}
\rhead{\Was}
\lhead{\leftmark}
\lfoot{Autor: \Autor, Kurs: \Kurs}
\rfoot{Seite \thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\fancypagestyle{simple}{
  \fancyhf{}
  \rhead{\Was}
  \lfoot{Autor: \Autor, Kurs: \Kurs}
  \rfoot{Seite \thepage}
}

% acronyms
\acsetup{
  list/display = used,
  pages/display = first
}

\newcommand{\reals}{\ensuremath{\mathbb{R}}}
\newcommand{\natnums}{\ensuremath{\mathbb{N}}}

% code snippet setup
\renewcommand{\lstlistingname}{Code-Auszug}
\renewcommand{\lstlistlistingname}{Liste der Code-Auszüge}

\definecolor{black}{rgb}{0,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{brown}{rgb}{0.69,0.31,0.31}

% python
\lstdefinelanguage{Python}{
  morekeywords={import, def, from, for, in, if, else, return, True, False, catch, return, null, switch, if, in, while, do, else, case, break},
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]""",
  morestring=[b]'
}

\lstdefinestyle{light}{
  % General design
  basicstyle={\footnotesize\ttfamily},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Quellcode design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{green}\bfseries,
  stringstyle=\color{orange}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Quellcode
  alsodigit={.:;},
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
}

\begin{document}
\raggedright % sorgt dafür das alles strikt links ausgerichtet wird (und sorgt für mehr seiten)


% Titlepage
\makeatletter
\begin{titlepage}
  \begin{center}
    \vspace*{1cm}
    {\Huge\scshape \Was}\\[2cm]
    \begin{center}
      \linespread{1}\Huge \@title\\[2cm]
    \end{center}
    {\large \Studiengang}\\
    {\large Dualen Hochschule Baden-Württemberg\\ Stuttgart}\\[2cm]
    {\large von}\\
    {\large\bfseries \@author}
    \vfill
  \end{center}
  \begin{tabular}{l@{\hspace{2cm}}l}
    Matrikelnummer: & \MatrikelNummer \\
    Abgabedatum:    & \@date          \\
  \end{tabular}
\end{titlepage}
\makeatother

% Table of content
\tableofcontents

\newpage
%%%%%%
% Content here
%%%%%% 

\section{Einleitung}
% TODO entweder diese Überschrift weg oder hier noch was hinschreiben
% ein kleiner abstract könnte hier gut passen.

\section{Problemstellung}

Ein Rucksack hat eine bestimmte Tragekapazität (z.b. 6 Kg)
ein Dieb packt bei einem Wohnungsraub sein Diebesgut in diesen Rucksack.
In der Wohnung befinden sich Gegenstände mit unterschiedlichem Gewicht und Geldwert.
Gegenstände können verschieden oft vorhanden sein
(z.b. Schmuck 4kg 500€ 1stk, Elektrogeräte 3kg 400€ 3stk, Schuhe 2kg 300€ 1stk, Geld 1kg 200€ 2stk).
Der Dieb möchte bei dem Wohnungsraub einen möglichst großen Gewinn erzielen,
er möchte also den Geldwert der in den Rucksack gepackten Gegenstände maximieren,
da der Rucksack aber nur eine bestimmte Kapazität hat, muss zuerst ein Optimierungsproblem gelöst werden.
Dieses Problem nennt sich das \emph{Rucksackproblem} (oder Englisch: \emph{Knapsack Problem})

In diesem Beispiel wäre die beste Kombination: 1stk Geld, 1stk Schuhe, 1stk Elektrogeräte
damit wird ein Gesamtgewinn von 900€ und einem Gesammtgewicht von 6kg erreicht.

Mathematisch formuliert: Es gibt \(m\in\natnums\) Gegenstände.
Sei \(c_i\in\natnums : i\in I\) der Wert des Gegenstandes \(i\),
\(a_i\in\natnums : i\in I\) das Gewicht des Gegenstandes \(i\)
und \(u_i\in \natnums : i\in I\) wie oft der Gegenstand vorhanden ist jeweils mit \(i\in I = \{1 ,2 ,\ldots ,m\} \).
Die Tragekapazität des Rucksacks ist \(b\in\natnums\).
Dann wird für den maximal erreichbaren Geldwert in Abhängigkeit zur Tragekapazität des Rucksacks \(f(b)\) definiert:

\[
  f(b):=\max(\sum_{i=1}^m c_i x_i : \sum_{i=1}^m a_i x_i\leq b, 0\leq x_i\leq u_i,  x_i\in\natnums, i\in I)
\]

Das hier dargestellte Rucksackproblem ist ein begrenztes Rucksackproblem.
Beim unbegrenzten Rucksackproblem kann \(x_i\) jeden beliebigen wert in \(\natnums \) annehmen und ist nicht von \(u_i\) begrenzt.

Das am häufigsten auftretende Rucksackproblem ist das 0-1-Rucksackproblem.
Ein Begrenztes Rucksackproblem kann zu einem 0-1-Rucksackproblem vereinfacht werden, indem \(u_i=1\) gesetzt wird. Dann gilt:

\[
  f(b):=\max(\sum_{i\in I}c_i : \sum_{i\in I}a_i\leq b, i\in I)
\]

Anschaulich bedeutet das, dass jeder Gegenstand nur genau einmal vorhanden ist
und daher auch nur einmal mitgenommen werden kann.
Da das 0-1-Rucksackproblem das Häufigste in der Kategorie der Rucksackprobleme ist,
soll der Fokus im Folgenden auf dem 0-1-Rucksackproblem liegen.
% TODO umwandlung normales Rucksack problem zu 01 problem

Das Rucksackproblem gehört zur Kategorie der am schwersten zu lösenden Probleme,
den \(\mathcal{NP}\)-vollständigen Problemen~\cite{mainKnapsack}.
In der Praxis gibt es aber einige Lösungsverfahren und einige Approximationsverfahren.

\subsection{\(\mathcal{NP}\)-vollständige Probleme}

Ein Algorithmus ist in polynomer Zeit lösbar,
wenn für die Zeitkomplexität \(O(n^k)\) gilt.
Dabei ist \(k\) eine positive ganze Zahl und \(n\) die Komplexität des Eingabewertes.
Diese Algorithmen haben die Zeitkomplexität \(\mathcal{P}\) (Polynome Zeit).

Algorithmen, die sich nicht mit dieser Zeitkomplexität beschreiben lassen,
nennt man \(\mathcal{NP}\)-vollständige Probleme.
Diese Probleme lassen sich nur mithilfe von Nichtdeterministischen Operationen
in polynomer Zeit lösen.
Am Modell einer Turing-Maschine erklärt bedeutet Nichtdeterminismus,
dass der Nächste Zustand nicht unbedingt durch die vorhergehenden Zustände bestimmt ist.
Während eine Nichtdeterministische Turing-Maschine die richtige Auswahl in polynomer Zeit weiß,
muss eine deterministische Turing-Maschine alle Möglichkeiten ausprobieren, um die richtige Auswahl zu erhalten
und benötigt dafür deutlich länger als polynome Zeit.
\(\mathcal{NP}\)-vollständige Probleme sind daher für einen Computer
die am schwersten zu lösenden Probleme.

Ob sich \(\mathcal{NP}\)-vollständige Probleme allgemein in \(\mathcal{P}\) Probleme umformen lassen,
ist eine bisher ungelöste Frage~\cite[Kap. 15]{KombinatorischeOptimierung}.

\section{Anwendungen}

Das Rucksackproblem tritt in der realen Welt häufiger bei Optimierungsproblemen,
speziell bei Problemen in der Ressourcen Allokation auf.
Man denke beispielsweise an einen LKW, der ein bestimmtes Transportvolumen hat und Güter,
die bei verschiedenem Volumen einen unterschiedlichen Gewinn erzielen.
Oder ein Containerschiff das ein bestimmtes Gewicht Tragen kann
und Container mit unterschiedlichem Gewicht und Gewinn.

Zusätzlich zu den praktischen Anwendungen gibt es auch theoretische Anwendungen für das Rucksackproblem.
Rucksackprobleme sind ganzzahlige lineare Optimierungsprobleme.
Andere ganzzahlige lineare Optimierungsprobleme können in Rucksackprobleme umgeformt werden~\cite{mainKnapsack},
die umgeformte Version des Problems hat dabei dieselben Lösungen wie das Originalproblem~\cite{mainKnapsack}.
Das heißt es können die bekannten Lösungsverfahren zur Lösung des Rucksackproblems
auch bei anderen ganzzahligen linearen Optimierungsproblemen verwendet werden.

% TODO vielleicht entfernen.
Eine Problemvariante des Rucksackproblems, die Subset Sum wird in der Kryptographie verwendet,
beispielsweise beim Merkle-Hellman-Kryptosystem.

\section{Lösungsansverfahren}

\subsection{Brute Force}

Bei \(n\) zur Auswahl stehender Elemente, gibt es \(2^n\) Möglichkeiten verschiedene Kombinationen von Gegenständen daraus zu wählen.
Bei jeder Iteration wird dann überprüft,
ob die jetzige Kombination von Gegenständen die beste bisher ist.
Ist sie das, wird die bisher beste Kombination ersetzt und der neue beste Wert gespeichert~\cite{paper102}.
Der Algorithmus hat damit eine Komplexität von \(O(n2^n)\).
Er ist damit der schlechtest mögliche Algorithmus.

\subsection{Dynamische Optimierung}
\label{sec:dyn_opt}

Das im Folgenden vorgestellte Verfahren funktioniert zur Lösung des 0-1-Rucksackproblems.
In der Literatur wird dieser Algorithmus verschieden genannt.
In~\cite{scheiterhauer2008} wird dieser Algorithmus \emph{Algorithmus von Gilmore und Gomoroy} genannt,
in~\cite{KombinatorischeOptimierung} wird der Algorithmus entweder \emph{pseudopolynomieller Algorhitmus} oder
\emph{Algorithmus von Bellman und Dantzig}~\cite{KombinatorischeOptimierung} genannt,
in~\cite{paper102,intro_survey} und in anderen Publikationen wird der Algorithmus einfach
\emph{Algorithmus mit Dynamischer Optimierung} genannt.
Diese Bezichnung wird hier auch verwendet.

Der hier vorgestellte basiert auf \emph{dynamischer Optimierung}.
Dafür wird das Rucksackproblem zuerst vollständig reduziert
und dann schrittweise wieder zum Originalproblem aufgebaut.

Begonnen wird mit dem einfachsten Problem: einem Rucksack mit Kapazität 0 mit einem Gegenstand zu füllen.
Die Kapazität wird schrittweise erhöht bis die Originalkapazität erreicht ist.
Es wird bei jeder Erhöhung der Kapazität geprüft, ob der Gegenstand hinzugefügt werden kann
und ob dies einen Vorteil gegenüber der vorherigen Iteration bringt.
Der Gegenstand wird hinzugefügt oder nicht basierend darauf was den Wert im Rucksack am höchsten werden lässt.
Dann wird der nächste Gegenstand dazu genommen und die Kapazität des Rucksacks wieder auf 0 gesetzt.
Wichtig ist dabei, dass die Gegenstände im Wert absteigend ausgewählt werden.
Mit einem Gegenstand mehr wird wieder mit der Erhöhung der Rucksack Kapazität von 0 bis zur Originalkapazität begonnen.
Das wird so lange wiederholt, bis versucht wurde alle Gegenstände hinzuzufügen~\cite{scheiterhauer2008}.
Der maximal erzielbare Wert im Rucksack steht im unteren rechten Feld der Matrix,
und ist das Ergebnis des Algorithmus.

In~\ref{lst:dyn_opt} ist dieser Algorithmus beispielhaft in Python implementiert.
Die Tabelle~\ref{tab:mat} zeigt das Ergebnis dieses Algorithmus für die Eingabe aus~\ref{tab:input}.

Um herauszufinden welche Gegenstände in den Rucksack aufgenommen wurden,
muss die Matrix schrittweise zurückverfolgt werden.
Begonnen wird dabei mit dem unteren rechten Eintrag der Matrix.
Ein Gegenstand \(i\) ist im Rucksack vorhanden,
wenn im Vergleich zum vorherigen Gegenstand ein Gewinn erzielt wurde,
also \(m(i,j)\neq m(i-1,j)\) mit \(m\) als Lösungsmatrix (siehe~\ref{tab:mat}).
Dieser Gegenstand wird dann dem Rucksack hinzugefügt
und die verbleibende Kapazität im Rucksack verringert.
Der nächste Eintrag in der Matrix der betrachtet werden muss
ist dann also \(m(i-1,j-weight[i])\).\\
Wenn \(m(i,j) = m(i-1,j)\) gilt,
dann ist der Gegenstand \(i\) nicht im Rucksack vorhanden.
Der nächste Matrixeintrag der betrachtet werden muss ist dann \(m(i-1,j)\).\\
Das wird wiederholt bis der obere linke Matrixeintrag erreicht ist.


\begin{table}
  \renewcommand{\arraystretch}{1.2}
  \centering
  \begin{tabular}{c|c|c}
    wert & gewicht & index \\
    \hline
    500€ & 4kg     & 1     \\
    400€ & 3kg     & 2     \\
    300€ & 2kg     & 3     \\
    200€ & 1kg     & 4
  \end{tabular}
  \caption{Werte}
  \label{tab:input}
\end{table}

\begin{table}
  \renewcommand{\arraystretch}{1.2}
  \centering
  \begin{tabular}{c |c c c c c c c}
      & 0kg & 1kg  & 2kg  & 3kg  & 4kg  & 5kg  & 6kg  \\
    \hline
    0 & 0€  & 0€   & 0€   & 0€   & 0€   & 0€   & 0€   \\
    1 & 0€  & 0€   & 0€   & 0€   & 500€ & 500€ & 500€ \\
    2 & 0€  & 0€   & 0€   & 400€ & 500€ & 500€ & 500€ \\
    3 & 0€  & 0€   & 300€ & 400€ & 500€ & 700€ & 800€ \\
    4 & 0€  & 200€ & 300€ & 500€ & 600€ & 700€ & 900€
  \end{tabular}
  \caption{Lösungsmatrix}
  \label{tab:mat}
\end{table}

\begin{figure}
  \begin{lstlisting}[language=Python,style=light,caption={Gilmore Gomoroy in Python}, label={lst:dyn_opt}]
from numpy import zeros

def gilmore_gomoroy(v, b):
  """
  Parameters: 
  v (array) list of (value, weight) tuples
  b (int) knapsack capacity

  Returns
  m (array): solution matrix
  """

  # Matrix with solution
  m = zeros((len(v)+1, b+1))

  for i in range(1, len(v)+1):
    for j in range(1, b+1):
      weight = v[i-1][1]
      value = v[i-1][0]
      if weight > j:
        m[i, j] = m[i-1, j]
      else:
        m[i, j] = max(m[i-1, j], m[i-1, j-weight] + value)

  return m
\end{lstlisting}
\end{figure}

Der Algorithmus hat die Komplexität \(O(nb)\),
wobei \(b\) die maximale Kapazität des Rucksacks darstellt.
Algorithmen mit einer solchen Komplexität werden \emph{pseudo- polynomial} genannt~\cite{scheiterhauer2008}.

% TODO hier könnte noch gut die längste weg methode aus \cite*{scheiterhauer2008} Kap 2.3 hin 
% TODO oder/und branch and bound aus paper102 / 1.2.2 aus mainKnapsack

\section{Annäherungsverfahren}

\subsection{Greedy Algorithmus}

% TODO vielleicht ein beispiel hier?

Bei vielen Optimierungsproblemen wird ein Greedy Algorithmus eingesetzt,
um das Problem zu lösen oder die Lösung zumindest gut annähern zu können~\cite{paper102}.

Für das 0-1-Rucksackproblem Problem gibt es mehrere Greedy Strategien.

\begin{enumerate}
  \item Schritt für Schritt Gegenstände mit absteigendem Wert wählen und in den Rucksack Packen.
  \item Schritt für Schritt Gegenstände mit aufsteigendem Gewicht in den Rucksack Packen.
  \item Schritt für Schritt Gegenstände mit aufsteigendem Wert pro Gewicht in den Rucksack Packen.
\end{enumerate}

Dabei erzielt die letzte Strategie in der Praxis die besten Ergebnisse~\cite{paper102}.\\
Die Zeitkomplexität dieses Algorithmus ist \(O(n\log n)\)

\subsection{Voll-polynomielles Approximationsverfahren}

Für das Rucksackproblem gibt es kein Polynomielles Lösungsverfahren.
Mithilfe des Lösungsverfahrens mit dynamischer Optimierung
kann aber ein voll polynomielles Approximationsverfahren geschaffen werden~\cite{KombinatorischeOptimierung}.

Die Laufzeit des Verfahrens mit dynamischer Optimierung
hängt direkt von der Kapazität des Rucksacks ab.
Daher liegt es nahe, die Gewichte und die Kapazität zu halbieren und abzurunden.

\[
  a^*_i := \left\lfloor\frac{a_i}{t}\right\rfloor \;:\; i\in I\;;\; b^* := \left\lfloor\frac{b}{t}\right\rfloor
\]

Damit kann die Laufzeit des Algorithmus in Abschnitt~\ref{sec:dyn_opt}
von \(O(nb)\) auf \(O(n\frac{b}{t})\) reduziert werden.
% TODO hier weitermachen

% TODO weitere Rucksackprobleme wie z.b. Multiple choice Rucksackproblem (siehe \cite{intro_survey})


\newpage
\printbibliography

\end{document}
