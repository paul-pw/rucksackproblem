\documentclass[12pt, a4paper, ngerman]{article}
\title{Das Rucksackproblem}
\author{Paul Walker und Tom Hofer}
\date{30.06.2022}
\newcommand{\Autor}{Paul Walker und Tom Hofer}
\newcommand{\Kurs}{TINF20IN}
\newcommand{\MatrikelNummer}{3610783, 4775319}
\newcommand{\Was}{Hausarbeit Rucksackproblem}
\newcommand{\Studiengang}{Diskrete Mathematik}

\usepackage{biblatex} % für bibliografie
\usepackage{hyperref} % für links zum klicken
\usepackage{color}    % für Farben (benötigt für listings)
\usepackage{listings} % code schnipsel
\usepackage[ngerman]{babel} % lokalisierung der Titel (Inhaltsverzeichniss)
\usepackage{bookmark} % bookmarks für das PDF
\usepackage{csquotes} % korrekte quotes
\usepackage[version=3]{acro} % akronyme
\usepackage{geometry} % seitengeometrie (margin etc einstellen)
\usepackage{parskip}  % zeilenabstand bei neuem paragraph statt indentierung
\usepackage{fancyhdr} % header und footer
\usepackage{array}    % für bessere Tabellen
\usepackage{titlesec} % um die Titel anzupassen
\usepackage{amsfonts} % für \mathbb

\hypersetup{
  pdfauthor={\Autor},
  pdftitle={\Was},
  hidelinks
}

\geometry{
  a4paper,
  left=25mm,
  right=25mm,
  headheight=125mm,
  top=35mm,
  bottom=30mm,
  footskip=15mm
}

% title setup 
% make paragraph have a newline
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% add bibliography
\addbibresource{bibliography.bib}

% header and footer setup
\pagestyle{fancy}
\fancyhf{}
\rhead{\Was}
\lhead{\leftmark}
\lfoot{Autor: \Autor, Kurs: \Kurs}
\rfoot{Seite \thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\fancypagestyle{simple}{
  \fancyhf{}
  \rhead{\Was}
  \lfoot{Autor: \Autor, Kurs: \Kurs}
  \rfoot{Seite \thepage}
}

% acronyms
\acsetup{
  list/display = used,
  pages/display = first
}

% TODO Acronyms here
%\DeclareAcronym{mvvm}{short=MVVM, long=Model-View-Viewmodel}

\newcommand{\reals}{\ensuremath{\mathbb{R}}}
\newcommand{\natnums}{\ensuremath{\mathbb{N}}}

% code snippet setup
\renewcommand{\lstlistingname}{Code-Auszug}
\renewcommand{\lstlistlistingname}{Liste der Code-Auszüge}

\definecolor{black}{rgb}{0,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{brown}{rgb}{0.69,0.31,0.31}

% python
\lstdefinelanguage{Python}{
  morekeywords={import, def, from, for, in, if, else, return, True, False, catch, return, null, switch, if, in, while, do, else, case, break},
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]""",
  morestring=[b]'
}

\lstdefinestyle{light}{
  % General design
  basicstyle={\footnotesize\ttfamily},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Quellcode design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{green}\bfseries,
  stringstyle=\color{orange}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Quellcode
  alsodigit={.:;},
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
}

\begin{document}
\raggedright % sorgt dafür das alles strikt links ausgerichtet wird (und sorgt für mehr seiten)


% Titlepage
\makeatletter
\begin{titlepage}
  \begin{center}
    \vspace*{1cm}
    {\Huge\scshape \Was}\\[2cm]
    \begin{center}
      \linespread{1}\Huge \@title\\[2cm]
    \end{center}
    {\large \Studiengang}\\
    {\large Dualen Hochschule Baden-Württemberg\\ Stuttgart}\\[2cm]
    {\large von}\\
    {\large\bfseries \@author}
    \vfill
  \end{center}
  \begin{tabular}{l@{\hspace{2cm}}l}
    Matrikelnummer: & \MatrikelNummer \\
    Abgabedatum:    & \@date          \\
  \end{tabular}
\end{titlepage}
\makeatother

% Table of content
\tableofcontents

% TODO entfernen wenn nicht weiter benötigt
\newpage
\thispagestyle{simple}
\printacronyms[name=Abkürzungsverzeichnis, heading=section*]
\newpage

%%%%%%
% Content here
%%%%%% 

\section{Einleitung}

\section{Problemstellung}

Ein Rucksack hat eine bestimmte Tragekapazität (z.b. 6 Kg)
ein Dieb packt bei einem Wohnungsraub sein Diebesgut in diesen Rucksack.
In der Wohnung befinden sich Gegenstände mit unterschiedlichem Gewicht und Geldwert.
Gegenstände können verschieden oft vorhanden sein
(z.b. Schmuck 4kg 500€ 1stk, Elektrogeräte 3kg 400€ 3stk, Schuhe 2kg 300€ 1stk, Geld 1kg 200€ 2stk).
Der Dieb möchte bei dem Wohnungsraub einen möglichst großen Gewinn erzielen,
er möchte also den Geldwert der in den Rucksack gepackten Gegenstände maximieren,
da der Rucksack aber nur eine bestimmte Kapazität hat, muss zuerst ein Optimierungsproblem gelöst werden.
Dieses Problem nennt sich das \emph{Rucksackproblem} (oder Englisch: \emph{Knapsack Problem})

In diesem Beispiel wäre die beste Kombination: 1stk Geld, 1stk Schuhe, 1stk Elektrogeräte
damit wird ein Gesamtgewinn von 900€ und einem Gesammtgewicht von 6kg erreicht.

Mathematisch formuliert: Es gibt \(m\in\natnums\) Gegenstände.
Sei \(c_i\in\natnums : i\in I\) der Wert des Gegenstandes \(i\),
\(a_i\in\natnums : i\in I\) das Gewicht des Gegenstandes \(i\)
und \(u_i\in \natnums : i\in I\) wie oft der Gegenstand vorhanden ist jeweils mit \(i\in I = \{1 ,2 ,\ldots ,m\} \).
Die Tragekapazität des Rucksacks ist \(b\in\natnums\).
Dann wird für den maximal erreichbaren Geldwert in Abhängigkeit zur Tragekapazität des Rucksacks \(f(b)\) definiert:

\[
  f(b):=\max(\sum_{i=1}^m c_i x_i : \sum_{i=1}^m a_i x_i\leq b, 0\leq x_i\leq u_i,  x_i\in\natnums, i\in I)
\]

Das hier dargestellte Rucksackproblem ist ein begrenztes Rucksackproblem.
Beim unbegrenzten Rucksackproblem kann \(x_i\) jeden beliebigen wert in \(\natnums \) annehmen und ist nicht von \(u_i\) begrenzt.

Das am häufigsten auftretende Rucksackproblem ist das 0-1-Rucksackproblem.
Ein Begrenztes Rucksackproblem kann zu einem 0-1-Rucksackproblem vereinfacht werden, indem \(u_i=1\) gesetzt wird. Dann gilt:

\[
  f(b):=\max(\sum_{i\in I}c_i : \sum_{i\in I}a_i\leq b, i\in I)
\]

Anschaulich bedeutet das, dass jeder Gegenstand nur genau einmal vorhanden ist
und daher auch nur einmal mitgenommen werden kann. Da das 0-1-Rucksackproblem das Häufigste in der Kategorie der Rucksackprobleme ist, soll der Fokus im Folgenden auf dem 0-1-Rucksackproblem liegen. % TODO umwandlung normales Rucksack problem zu 01 problem

Das Rucksackproblem gehört zur Kategorie der am schwersten zu lösenden Probleme,
den \(\mathcal{NP}\)-complete Problemen~\cite{mainKnapsack}.
In der Praxis gibt es aber einige Lösungsverfahren und einige Approximationsverfahren.

\subsection{NP-complete Probleme}
Zusätzlich zur Problemklasse NP gibt es auch die Klasse P. P enthält alle Probleme, welche durch einen polynomiellen Algorithmus gelöst werden können. Die Frage ob P = NP gilt, konnte bisher weder bestätigt, noch wiederlegt werden.
\cite[Kap. 15]{KombinatorischeOptimierung}

\section{Anwendungen}

Das Rucksackproblem tritt in der realen Welt häufiger bei Optimierungsproblemen,
speziell bei Problemen in der Ressourcen Allokation auf.
Man denke beispielsweise an einen LKW, der ein bestimmtes Transportvolumen hat und Güter,
die bei verschiedenem Volumen einen unterschiedlichen Gewinn erzielen.
Oder ein Containerschiff das ein bestimmtes Gewicht Tragen kann
und Container mit unterschiedlichem Gewicht und Gewinn.

Zusätzlich zu den praktischen Anwendungen gibt es auch theoretische Anwendungen für das Rucksackproblem.
Rucksackprobleme sind ganzzahlige lineare Optimierungsprobleme.
Andere ganzzahlige lineare Optimierungsprobleme können in Rucksackprobleme umgeformt werden\cite{mainKnapsack},
die umgeformte Version des Problems hat dabei dieselben Lösungen wie das Originalproblem\cite{mainKnapsack}.
Das heißt es können die bekannten Lösungsverfahren zur Lösung des Rucksackproblems
auch bei anderen ganzzahligen linearen Optimierungsproblemen verwendet werden.

% TODO vielleicht entfernen.
Eine Problemvariante des Rucksackproblems, die Subset sum wird in der Kryptographie verwendet,
beispielsweise beim Merkle-Hellman-Kryptosystem (das sich nicht als besonders sicher herausstellte).

\section{Lösungsansätze}

\subsection{Brute Force}

Bei \(n\) zur Auswahl stehender Elemente, gibt es \(2^n\) Möglichkeiten verschiedene Kombinationen von Gegenständen daraus zu wählen.
Bei jeder Itteration wird dann überprüft,
ob die jetzige Kombination von Gegenständen die beste bisher ist.
Ist sie das, wird die bisher beste Kombination ersetzt und der neue beste Wert gespeichert~\cite{paper102}.
Der Algorithmus hat damit eine Komplexität von \(O(n2^n)\).
Er ist damit der schlechtest mögliche Algorithmus.

\subsection{Algorhitmus von Gilmore und Gomoroy}

Das im Folgenden vorgestellte Verfahren funktioniert zur Lösung des 0-1-Rucksackproblems.
Der Algorhitmus von Gilmore un Gomoroy basiert auf \emph{dynamischer Optimierung}.
Dafür wird das Rucksackproblem zuerst Vollständig reduziert
und dann schrittweise wieder zum Originalproblem aufgebaut.
Begonnen wird mit dem simpelsten Problem: einem Rucksack mit Kapazität 0 und mit einem Gegenstand.
Die Kapazität wird schrittweise erhöht bis die Originalkapazität erreicht ist.
Es wird bei jeder Erhöhung der Kapazität geprüft, ob der Gegenstand hinzugefügt werden kann
und ob dies einen Vorteil gegenüber der vorherigen Iteration bringt.
Der Gegenstand wird hinzugefügt oder nicht basierend darauf was am meisten gewinn erzielt.
Dann wird der nächste Gegenstand genommen und die Kapazität des Rucksacks wieder auf 0 gesetzt.
Wichtig ist dabei, dass die Gegenstände im Wert absteigend ausgewählt werden.
Nun wird wieder mit der Erhöhung der Rucksack Kapazität begonnen.
Das wird so lange wiederholt, bis versucht wurde alle Gegenstände hinzuzufügen~\cite{scheiterhauer2008}.
Der maximal erzielbare Wert im Rucksack steht im unteren rechten Feld der Matrix,
und ist das Ergebnis des Algorithmus.

In~\ref{lst:gg} ist dieser Algorithmus beispielhaft in Python implementiert.
Die Tabelle~\ref{table:2} zeigt das Ergebnis dieses Algorithmus für die Eingabe aus~\ref{table:1}.
Um herauszufinden welche Gegenstände in den Rucksack aufgenommen wurden,
muss die Matrix einfach schrittweise zurückverfolgt werden.

\begin{table}
  \renewcommand{\arraystretch}{1.2}
  \centering
  \begin{tabular}{c|c|c}
    wert & gewicht & index \\
    \hline
    500€ & 4kg     & 1     \\
    400€ & 3kg     & 2     \\
    300€ & 2kg     & 3     \\
    200€ & 1kg     & 4
  \end{tabular}
  \caption{Werte}
  \label{table:1}
\end{table}

\begin{table}
  \renewcommand{\arraystretch}{1.2}
  \centering
  \begin{tabular}{c |c c c c c c c}
      & 0kg & 1kg  & 2kg  & 3kg  & 4kg  & 5kg  & 6kg  \\
    \hline
    0 & 0€  & 0€   & 0€   & 0€   & 0€   & 0€   & 0€   \\
    1 & 0€  & 0€   & 0€   & 0€   & 500€ & 500€ & 500€ \\
    2 & 0€  & 0€   & 0€   & 400€ & 500€ & 500€ & 500€ \\
    3 & 0€  & 0€   & 300€ & 400€ & 500€ & 700€ & 800€ \\
    4 & 0€  & 200€ & 300€ & 500€ & 600€ & 700€ & 900€
  \end{tabular}
  \caption{Lösungsmatrix}
  \label{table:2}
\end{table}


\begin{lstlisting}[language=Python,style=light,caption={Gilmore Gomoroy in Python}, label={lst:gg}]
from numpy import zeros

def gilmore_gomoroy(v, c):
  """
  Parameters: 
  v (array) list of (value, weight) tuples
  c (int) knapsack capacity

  Returns
  m (array): solution matrix
  """

  # Matrix with solution
  m = zeros((len(v)+1, c+1))

  for i in range(1, len(v)+1):
    for j in range(1, c+1):
      weight = v[i-1][1]
      value = v[i-1][0]
      if weight > j:
        m[i, j] = m[i-1, j]
      else:
        m[i, j] = max(m[i-1, j], m[i-1, j-weight] + value)

  return m
\end{lstlisting}

Der Algorithmus hat die Komplexität \(O(nc)\),
wobei \(c\) die maximale Kapazität des Rucksacks darstellt.
Algorithmen mit einer solchen Komplexität werden \emph{pseudo- polynomial} genannt~\cite{scheiterhauer2008}.

\subsection{Annäherungsalgorithmen}


\subsubsection{Greedy Algorhitmus}

% TODO vielleicht ein beispiel hier?

Bei vielen Optimierungsproblemen wird ein Greedy Algorithmus eingesetzt,
um das Problem zu lösen oder die Lösung zumindest gut annähern zu können~\cite{paper102}.

Für das 0-1-Rucksackproblem Problem gibt es mehrere Greedy Strategien.

\begin{enumerate}
  \item Schritt für Schritt Gegenstände mit absteigendem Wert wählen und in den Rucksack Packen.
  \item Schritt für Schritt Gegenstände mit aufsteigendem Gewicht in den Rucksack Packen.
  \item Schritt für Schritt Gegenstände mit aufsteigendem Wert pro Gewicht in den Rucksack Packen.
\end{enumerate}

Dabei erzielt die letzte Strategie in der Praxis die besten Ergebnisse~\cite{paper102}.\\
Die Zeitkomplexität dieses Algorithmus ist \(O(n\log n)\)

\newpage
\printbibliography

\end{document}
